# 锁

在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，需要对 `并发操作进行控制` ，因此产生了 锁 。同时 `锁机制` 也为实现MySQL的各个隔离级别提供了保证。 `锁冲突` 也是影响数据库 `并发访问性能` 的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。

锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。==如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。==从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。  

## MySQL并发事务访问相同记录

并发事务访问相同记录的情况大致可以划分为3种：  

###  读-读情况  

读-读 情况，即并发事务相继 `读取相同的记录` 。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。

### 写-写情况

写-写 情况，即并发事务相继对相同的记录做出改动。

在这种情况下会发生 `脏写` 的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们 `排队执行` ，这个排队的过程其实是通过 `锁` 来实现的。这个所谓的锁其实是一个 `内存中的结构` ，在事务执行前本来是没有锁的，也就是说一开始是没有 锁结构 和记录进行关联的，如图所示：
当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的 锁结构 ，当没有的时候就会在内存中生成一个 锁结构 与之关联。比如，事务 T1 要对这条记录做改动，就需要生成一个`锁结构`与之关联

![](https://raw.githubusercontent.com/Swiftie13st/Figurebed/main/img/202302240907944.png)

小结几种说法：  
- 不加锁  
意思就是不需要在内存中生成对应的 锁结构 ，可以直接执行操作。  
- 获取锁成功，或者加锁成功  
意思就是在内存中生成了对应的 锁结构 ，而且锁结构的 is_waiting 属性为 false ，也就是事务  可以继续执行操作。  
- 获取锁失败，或者加锁失败，或者没有获取到锁
  意思就是在内存中生成了对应的 锁结构 ，不过锁结构的 is_waiting 属性为 true ，也就是事务  需要等待，不可以继续执行操作。

### 读-写或写-读情况

读-写 或 写-读 ，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生 `脏读` 、 `不可重复读` 、 `幻读`的问题。  

各个数据库厂商对 SQL标准 的支持都可能不一样。比如MySQL在 `REPEATABLE READ` 隔离级别上就已经解决了 `幻读` 问题。

### 并发问题的解决方案

怎么解决 `脏读` 、 `不可重复读` 、 `幻读` 这些问题呢？其实有两种可选的解决方案：

方案一：读操作利用多版本并发控制（ `MVCC` ，下章讲解），写操作进行 `加锁` 。

>普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。
>在 `READ COMMITTED` 隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了 ==事务不可以读取到未提交的事务所做的更改== ，也就是避免了脏读现象
>在 `REPEATABLE READ` 隔离级别下，一个事务在执行过程中只有 第一次执行SELECT操作才会生成一个ReadView，之后的SELECT操作都 `复用` 这个ReadView，这样也就避免了不可重复读和幻读的问题。

方案二：读、写操作都采用 `加锁` 的方式。

小结对比发现：  

- 采用 `MVCC` 方式的话， 读-写 操作彼此并不冲突， **性能更高**。  
- 采用 `加锁` 方式的话， 读-写 操作彼此需要 `排队执行` ，影响性能。  

一般情况下我们当然愿意采用 MVCC 来解决 读-写 操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用 加锁 的方式执行。下面就讲解下MySQL中不同类别的锁


## MySQL中的锁

![](https://raw.githubusercontent.com/Swiftie13st/Figurebed/main/img/202302240914797.png)

MySQL中的锁，按照**锁的粒度**分，分为以下三类：  
- 全局锁：锁定数据库中的所有表。  
- 表级锁：每次操作锁住整张表。  
- 行级锁：每次操作锁住对应的行数据。

### 数据操作的类型划分：读锁、写锁  

- `读锁` ：也称为 `共享锁` （Shared Lock）、英文用 `S` 表示。针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。  
- `写锁` ：也称为 `排他锁` （Exclusive Lock）、英文用 `X` 表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。  

>需要注意的是对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上。

### 从数据操作的粒度划分：表级锁、页级锁、行锁  

他们的加锁开销从大到小，并发能力也是从大到小。

在关系型数据库中，可以**按照锁的粒度把数据库锁分**为行级锁(INNODB引擎)、表级锁(MYISAM引擎 )和页级锁(BDB引擎 )。

#### 行级锁

- 行级锁是MySQL中锁定粒度最细的一种锁，表示只针对`当前操作的行`进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。
- ==开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。==

#### 表级锁

- 表级锁是MySQL中`锁定粒度最大`的一种锁，表示对`当前操作的整张表`加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。
- ==开销小，加锁快；**不会出现死锁**；锁定粒度大，发出锁冲突的概率最高，并发度最低。==

#### 页级锁

- 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁
- ==开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般==

**MyISAM和InnoDB存储引擎使用的锁：**

- MyISAM采用表级锁(table-level locking)。
- InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁


### 从对待锁的态度划分:乐观锁、悲观锁

数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。

#### 悲观锁：

假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。==共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程==。
实现方式：使用数据库中的锁机制

#### 乐观锁：

==假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性==。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。
实现方式：乐一般会使用版本号机制或CAS算法实现。

##### 乐观锁的版本号机制 

在表中设计一个 版本字段 version ，第一次读的时候，会获取 version 字段的取值。然后对数据进行更新或删除操作时，会执行 UPDATE ... SET version=version+1 WHERE version=version 。此时如果已经有事务对这条数据进行了更改，修改就不会成功。

##### 乐观锁的时间戳机制  

时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行比较，如果两者一致则更新成功，否则就是版本冲突。  
你能看到乐观锁就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳（版本号或者时间戳），从而证明当前拿到的数据是否最新。

#### 两种锁的使用场景

从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。

但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。

1. 乐观锁 适合 `读操作多` 的场景，相对来说写的操作比较少。它的优点在于 `程序实现` ， `不存在死锁`问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。  
2. 悲观锁 适合 `写操作多` 的场景，因为写的操作具有 `排它性` 。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止 读 - 写 和 写 - 写 的冲突。

### 按加锁的方式划分：显式锁、隐式锁

所谓的显示和隐式就是在使用的时候，使用者要不要手动写代码去获取锁和释放锁。

- `显式锁`：通过特定的语句进行加锁，我们一般称之为显示加锁。
- `隐式锁`：存储引擎自动加的锁。如：InnoDB的每条记录中都一个隐含的trx_id字段，在操作一条记录前，首先根据记录中的trx_id检查该事务是否是活动的事务(未提交或回滚)。如果是活动的事务，就是为该事务添加一个锁。

### 其它锁之：全局锁

全局锁就是对 `整个数据库实例` 加锁。当你需要让整个库处于 只读状态 的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。全局锁的典型使用 场景 是：做 `全库逻辑备份` 。

```sql
Flush tables with read lock
```

### 其它锁之：死锁

死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。

#### 产生死锁的必要条件

1. 两个或两个以上的事务
2. 每个事务都已经持有锁并且申请新的锁
3. 锁资源只能被同一个事务持有或者不兼容
4. 事务之间因为持有锁和申请锁导致彼此循环等待

> 两个(以上)的Session加锁的顺序不一致

#### 出现死锁后的策略：

1. 一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数  `innodb_lock_wait_timeout`来设置。
   缺点：对于在线服务来说，这个等待时间往往是无法接受的。
   如果设置时间短一些容易误伤到普通的锁等待。
2. 另一种策略是，`发起死锁检测`，发现死锁后，主动回滚死锁链条中的某一个事务（==将持有最少行级排他锁的事务进行回滚==），让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为on ，表示开启这个逻辑。

#### 常见的解决死锁的方法：

1. 如果不同程序会并发存取多个表，**尽量约定以相同的顺序访问表，可以大大降低死锁机会。**
2. 在同一个事务中，尽可能做到**一次锁定所需要的所有资源**，减少死锁产生概率；
3. 对于**非常容易产生死锁**的业务部分，可以尝试使用**升级锁定颗粒度，通过表级锁定来减少死锁产生的概率**；

如果业务处理不好可以用分布式事务锁或者使用乐观锁


##  隔离级别与锁的关系

在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突

在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；

在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。

SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。

## 优化锁方面的意见？防止死锁

- 使用较低的隔离级别
- **设计索引，尽量使用索引去访问数据，加锁更加精确**，从而减少锁冲突
- 调整业务逻辑SQL执行顺序，避免update/delete长时间持有锁的SQL在事务前面。
- 避免大事务，尽量将达大事务拆成多个小事务来处理，小事务缩短锁定资源的时间，发生锁冲突的几率也更小。
- 选择合理的事务大小，给记录显示加锁时，最好一次性请求足够级别的锁。如：修改数据的话，最好申请排他锁，而不是先申请共享锁，修改时在申请排他锁，这样会导致死锁
- 不同的程序访问一组表的时候，应尽量约定一个相同的顺序访问各表，对于一个表而言，尽可能的固定顺序的获取表中的行。这样大大的减少死锁的机会。
- 尽量使用相等条件访问数据，这样可以避免间隙锁对并发插入的影响
- 不要申请超过实际需要的锁级别
- 数据查询的时候不是必要，不要使用加锁。MySQL的MVCC可以实现事务中的查询不用加锁，优化事务性能：MVCC只在committed read（读提交）和 repeatable read （可重复读）两种隔离级别
- 对于特定的事务，可以使用表锁来提高处理速度活着减少死锁的可能。