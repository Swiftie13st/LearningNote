## 排序算法

**选泡插，  
快归堆希桶计基，  
n方n老n一三，  
对n加kn乘k，  
不稳稳稳不稳稳，  
不稳不稳稳稳稳。**

堆排序、快速排序、希尔排序、直接选择排序**不是稳定**的排序算法；
基数排序、桶排序、计数排序、冒泡排序、直接插入排序、折半插入排序、归并排序**是稳定**的排序算法。

![image-202112231036653](https://raw.githubusercontent.com/Swiftie13st/Figurebed/main/img/202310181905808.png)

### 单链表快速排序 

需要两个指针p和q，这两个指针均往next方向移动，移动的过程中保持p之前的key都小于选定的key，p和q之间的key都大于选定的key，那么当q走到末尾的时候便完成了一次支点的寻找。  既然两个指针都是从前往后遍历，那么链表值进行交换就简单了。找到支点后，支点左边和支点右边进行子问题递归，就回到快排原来的思路上去了。

```go
func Quick(l, r *Node) {
    if l == r { return }
    x := l.Val
    p, q := l, l.Next
    for q != r {
        if q.Val < x {
            p = p.Next
            p.Val, q.Val = q.Val, p.Val
        }
        q = q.Next
    }
    p.Val, l.Val = l.Val, p.Val
    Quick(l, p)
    Quick(p.Next, r)
}
```

## 卡特兰数 

$$f(n)=\frac{C^{2n}_{n}}{n + 1}=C_n^{2n}-C_{n-1}^{2n} (n=0,1,2,\ldots)$$

1. 进出栈序列
2. 括号序列

$C_m^n=\frac{A_m^n}{A_n^n}$  $A_n^m=m\times(m-1)\times(m-2)\times\ldots\times(m-n+1)$  $A_8^4=8\times7\times6\times5$

## 哈希冲突 

### 开放定址法：

我们在遇到哈希冲突时，去寻找一个新的空闲的哈希地址。

1. 线性探测法：向后加1
2. 平方探测法（二次探测）：i为i^2,-i^2
3. 伪随机探测再散列

### 再哈希法：

同时构造多个不同的哈希函数，等发生哈希冲突时就使用第二个、第三个……等其他的哈希函数计算地址，直到不发生冲突为止。虽然不易发生聚集，但是增加了计算时间。

### 链地址法：

将所有哈希地址相同的记录都链接在同一链表中。

链过长先扩容，或用红黑树优化

## 红黑树

红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质：

-   性质1：每个节点要么是黑色，要么是红色。
-   性质2：根节点是黑色。
-   性质3：每个叶子节点（NIL）是黑色。
-   性质4：每个红色结点的两个子结点一定都是黑色。
-   **性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。**
	- 性质5.1：如果一个结点存在黑子结点，那么该结点肯定有两个子结点

 **从根到叶子的最长的可能路径不多于最短的可能路径的两倍长**

通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。
红黑树虽然本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。

3 个一组，左插左旋，右插右旋，中间晋升；  
一维列表，分组递归，代表排序，逐级上升；  
增删改查，定位小组，重复上述，得到答案。

![image-202305221936353](https://raw.githubusercontent.com/Swiftie13st/Figurebed/main/img/202310181905809.png)

### 与AVL的区别

平衡二叉树的性质： 它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。

1. 红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。
2. 平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。

## 跳表

-   跳表是可以实现二分查找的有序链表
-   每个元素插入时随机生成它的level
-   最底层包含所有的元素
-   如果一个元素出现在level(x)，那么它肯定出现在x以下的level中
-   每个索引节点包含两个指针，一个向下，一个向右；
-   跳表查询、插入、删除的时间复杂度为O(log n)，与平衡二叉树接近；

有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。

-   • 跳表由多层索引结构组成
-   • 每次节点个数接近于相邻下层节点数的一半
-   • 对于一个 m 层存在的节点，在 1~m-1层中这个节点也一定存在
-   • 为保证连贯性，跳表额外补充了本身不存储数据的头节点和尾节点，作为起点和终点
-   • 头节点和尾节点的高度是动态扩缩的，其高度取决于当前跳表内数据节点的最大高度
-   • 跳表的”跳“字体现在，在高层检索时，每跳过一个节点，实际上都过滤跳过了底层的大量数据，从而实现检索加速

### 实例

对比有序链表和跳跃表，从链表中查询出51

1. 有序链表
![image-202209291556542](https://raw.githubusercontent.com/Swiftie13st/Figurebed/main/img/202310181905810.png)
要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。
2. 跳跃表
![image-202209291556471](https://raw.githubusercontent.com/Swiftie13st/Figurebed/main/img/202310181905811.png)
从第2层开始，1节点比51节点小，向后比较。
21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层。
在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下。
在第0层，51节点为要查找的节点，节点被找到，共查找4次。

**从此可以看出跳跃表比有序链表效率要高**

### 跳表的层高是由什么决定的 

==每次插入会以百分之50的概率同时插入到上一层==，即从最底层插入百分之50概率同时插入到其上一层以此类推

层高基本为数据范围的log(n)，需限制层高


首先我们明确到，每个上层链表节点个数均为下层链表个数的一半，且是属于相邻下层链表中两两间隔存在的节点集合.
倘若需要严格保证这种间隔的疏密程度，代价将会是非常昂贵的. 此处我们选择退而求其次，转而保证下述的两项特性：

- 每个上层链表节点个数接近于相邻下层链表个数的一半
- 每个上层链表节点均在相邻下层链表中存在

注意，我们虽然放宽了对节点间隔宽度的要求，但只要我们保证了上层节点个数接近于相邻下层的一半，在大数据量的情况下，随机性问题会被转化为数学期望问题，最终同样能够实现上层索引的二分查找效果.
于是，我们将索引的建立时机放在插入节点的过程中. 每个节点在即将要插入到多层结构中时，我们对其层数进行随机取值，保证其高度为1层的概率为1/2；2层的概率为1/4；3层的概率为1/8，以此类推... 最终在形成大数据量时，整体结构的层高就会形成首层拥有全量数据，逐级往上、数量依次减半的规律.

### 为什么Redis选择使用跳表而不是红黑树来实现有序集合？

Redis 中的有序集合(zset) 支持的操作：

1.  插入一个元素
2.  删除一个元素
3.  查找一个元素
4.  有序输出所有元素
5.  按照范围区间查找元素（比如查找值在\[100, 356\] 之间的数据

其中，前四个操作红黑树也可以完成，且时间复杂度跟跳表是一样的。但是，`按照区间来查找数据`这个操作，红黑树的效率没有跳表高。按照区间查找数据时，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了，非常高效。

### 红黑树 vs 跳表

1. 时间复杂度：均为O(logN) 级别
2. 空间复杂度：均为O(N) 级别
3. 实现难易度：跳表的实现难度远低于红黑树。尽管红黑树相较于平衡搜索二叉树已经在平衡性上做了退让，从而降低了实现复杂度，但是其实现难度仍然保持在很高的水平
4. range 操作：跳表支持而红黑树不支持。此处的 range 操作指的是从有序表中获取到 key 值出在 \[l,r\] 区间内所有数据的批量查询操作。由于红黑树基于二叉树模型实现，因此对于这种范围查询并不能够很好地支持。跳表基于有序单向链表实现，因此天然能够支持这种范围查询操作。
5. 并发性：红黑树是粗锁和跳表可以支持细锁。红黑树由于其维护平衡性的手段涉及到节点旋转和节点染色，因此在并发操作时需要加全局锁，在基于全局数据结构互斥的情况下，串行化地执行数据的读写操作。与红黑树相对，跳表在并发读写时无须加持全局锁，而是可以基于更细粒度的锁，提高数据结构整体的并发性。

## B+树 & B树 

### B+树

1. B+树的**非叶子**节点**不保存具体的数据，而只保存关键字的索引**，而所有的数据最终都会保存到叶子节点。因为所有数据必须要到叶子节点才能获取到，所以每次数据查询的次数都一样，这样一来B+树的查询速度也就会比较稳定，而B树的查找过程中，不同的关键字查找的次数很有可能都是不同的（有的数据可能在根节点，有的数据可能在最下层的叶节点），所以在数据库的应用层面，B+树就显得更合适。
2.  B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。因为叶子节点都是有序排列的，所以B+树对于数据的排序有着更好的支持。

### B树

1. 排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；
2. 子节点数：非叶节点（根节点和枝节点）的子节点数 >1、且子节点数量<=M 、且M>=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；
3. 关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);
4. 所有叶子节点均在同一层、叶子节点除了包含了关键字 和 关键字记录的指针外，也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;

### mysql索引角度

-   B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。非叶子节点存放的是索引键值和页指针
-   B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。
-   B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。

**B+树**可以在内存有限的情况下存储更多的节点。B+树的内部节点不保存数据，只保存索引，而且内部节点的大小通常要比数据节点小得多，因此可以在内存中缓存更多的节点。
**B树**非叶子节点和叶子节点都会存储数据和索引，这样导致一页中存储的键值减少，指针跟着减少，要保存大量数据只能增加树的高度，导致性能降低。假设参数规格不变，存储一半数据，一半索引，第三层550 + 550 ^ 2 + 550 ^2 * 16= 480万，大概是B+树的1/4；

## 布隆过滤器

==由一个初值为0的bit数组和多个哈希函数构成，用于快速判断集合中是否存在某个元素。==
可以高效的插入和查询，占用空间少，返回的结果是不确定性+不够完美。
一个元素如果判断结果：**存在时元素不一定存在，但是判断结果为不存在时，则一定不存在。**

### 注意

布隆过滤器可以添加元素，但是**不能删除元素**，因为设计哈希函数判断，存在哈希冲突问题，删除元素可能会导致误判率增加。

当实际元素数量超过初始化数量时，应该对布隆过滤器进行重建，重新分配一个size更大的过滤器，在将所有的历史元素批量参加。

### 使用场景

1. 解决缓存穿透问题，和redis结合bitmap使用
2. 黑白名单
3. 安全连接网址，全球上10亿网址判断

![image-202303171911704](https://raw.githubusercontent.com/Swiftie13st/Figurebed/main/img/202310181905812.png)

### 如何防止布隆过滤器发生误判？

布隆过滤器是一种常用的数据结构，用于判断一个元素是否存在于一个集合中。它的优点是空间效率高，但是存在一定的误判率。为了防止误判，可以采用以下方法：  
  
1. 适当增加布隆过滤器的容量。增加容量可以降低误判率，但是会增加空间开销。  
2. 使用多个独立的布隆过滤器。多个布隆过滤器可以相互协作，降低误判率。但是会增加计算开销和空间开销。  
3. 使用其他数据结构辅助判断。例如，可以使用哈希表或红黑树等数据结构来存储布隆过滤器中的元素，以便在误判时进行二次判断。  
4. 选择合适的哈希函数。哈希函数的选择会影响误判率，因此需要根据实际情况选择合适的哈希函数。  
  
需要注意的是，以上方法并不能完全消除误判，只能降低误判率。如果需要更高的精度和可靠性，可以考虑使用其他数据结构，如哈希表、红黑树等