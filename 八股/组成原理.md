# 计组

## 机器数和真值

### 1、机器数

一个数在计算机中的二进制表示形式,  叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.

比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。

那么，这里的 00000011 和 10000011 就是机器数。

### 2、真值

因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。

例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1

## 源码补码反码

### 1. 原码

原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:

```text
[+1]原 = 0000 0001

[-1]原 = 1000 0001
```

第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:

\[1111 1111 , 0111 1111\] 即 \[-127 , 127\]

原码是人脑最容易理解和计算的表示方式.

### 2. 反码

反码的表示方法是:

- 正数的反码是其本身

- 负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.

```text
[+1] = [00000001]原 = [00000001]反
 
[-1] = [10000001]原 = [11111110]反
```


可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.

### 3. 补码

补码的表示方法是:

- 正数的补码就是其本身
- 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)

```text
[+1] = [00000001]原 = [00000001]反 = [00000001]补

[-1] = [10000001]原 = [11111110]反 = [11111111]补
```

对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.

### 负数使用补码存为什么？

-5是怎么存的？11111 1011

可以将==减法变为加法==，省去了减法器。
如：A - 127，  也就相当于：A + (-127)，  
又因为负数是以补码的形式保存的，也就是负数的真值是补码，既然这样，当我们要减一个数时，直接把其补码拿过来，加一下，就OK了，我们也可以放心地跟减法说拜拜了！

## 类型转换 

int8,int32...底层是怎么转换的？

加0、截取位数

int 是一个至少32位的有符号整数类型。但是，它是一个不同的类型，而不是int32的别名。int 和 int32 是两码事。
go语言中的int的大小是和操作系统位数相关的，如果是32位操作系统，int类型的大小就是4字节。如果是64位操作系统，int类型的大小就是8个字节。

### 强制类型转换会出什么问题

从低位转高位没有什么问题，从高位转低位时(会丢失精度)，int64转int8，这个转换的过程如下： 128的二进制：.........00000000_**1**0000000 因为是从int64转int8，所以截取128的后八位 ：**1**0000000 此时最高位是1，表示这是一个负数，此时结果是就是：-128

## 一个机器16位，32位，64位指的是什么？

[32位和64位到底有什么区别？_32位和64位的区别_ 瘦弱的皮卡丘的博客-CSDN博客](https://blog.csdn.net/ThinPikachu/article/details/123373252)
### CPU中

CPU的**字长。**

#### 字

在计算机中，一串二进制数码作为一个整体来处理或运算的，称为一个计算机字，简称字。字通常分为若干个字节。在存储器中，通常每个单元存储一个字，因此每个字都是可以寻址的。字的长度用位数来表示。在CPU的运算器、控制器中，通常都是以字为单位进行传送的。字出现在不同的地址其含义是不相同。例如，送往控制器去的字是指令，而送往运算器去的字就是一个数。

#### 字长

字长就是特定==CPU一次同时能处理的字的位数==，也就时长度，也就是==CPU一次能并行处理的二进制位数==。

每个时钟周期内，处理器处理二进制代码数，即“0”和“1”的个数。

字长与计算机的功能和用途有很大的关系，是计算机的一个重要技术指标。字长直接反映了一台计算机的计算精度，为适应不同的要求及协调运算精度和硬件造价间的关系，大多数计算机均支持变字长运算，即机内可实现半字长、全字长（或单字长）和双倍字长运算。在其他指标相同时，字长越大计算机的处理数据的速度就越快。

一台16位字长的PC机，可以直接处理2的16次方（65536）之内的数字，对于超过65536的数字就需要分解的方法来处理。32位pc机比16位机优越的原因就在于它在一次操作中能处理的数字大，32位字长的PC机能直接处理的数字高达40亿（2的32次方），能处理的的数字越大，则操作的次数就越少，从而系统的效率也就越高。早期的微机字长一般是8位和16位，386以及更高的处理器大多是32位。目前市面上的计算机的处理器大部分已达到64位。

#### CPU的字长由什么决定

CPU的字长由==CPU片内数据总线宽度==决定的。CPU有内部数据线和外部数据线之分，比如8086的CPU内部数据线为16位，而外部数据线为8位，那么就说它的字长为16位，仍是16位处理器，只不过是CPU与内存交换数据时是按8位方式传送数据的。又比如Pentium4 CPU内部数据线为32位，而外部地址线是36位， 外部数据线为64位，它的字长仍然为32位，所以Pentium4还是32位处理器，而不能称为64位处理器。

CPU的寄存器，说白了就是个存放数值的小盒子，盒子的大小，叫**位宽**。32位CPU能放入最大2^32的数值。64位就是最大2^64的值。这里的32位位宽的CPU就是我们常说的32位CPU，同理64位CPU也是一样
**总线**，也可以理解为有个宽度，比如宽度是32位，那么一次可以传32个0或1的信号，那么这个宽度能表达的数值范围就是0到2^32这么多。
32位CPU的总线宽度一般是32位，因为刚刚上面提到了，CPU可以利用地址总线在内存中进行寻址操作，那么现在这根地址总线，最大能寻址的范围，也就到2^32，其实就是4G。
64位CPU，按理说总线宽度是64位，但实际上是48位（也有看到说是40位或46位的，没关系，你知道它很大就行了），所以寻址范围能到2^48次方，也就是256T

### 系统和软件中

系统和软件的位数，可以理解为，这个系统或软件内存寻址的范围位数

在操作系统上运行一个用户态进程，会分为用户态和内核态，并设定一定的内存布局。操作系统和软件都需要以这个内存布局为基础运行程序。比如32位，内核态分配了1个G，用户态分配了3G，这种时候，你总不能将程序的运行内存边界设定在大于10G的地方。所以，系统和软件的位数，可以理解为，这个系统或软件内存寻址的范围位数。

### 程序中int32 int64

int32也就是用4个字节，32位的内存去存储数据，int64也就是用8个字节，64位去存数据。这个数值就是刚刚CPU运行流程中放在**内存里**的数据。

32位的CPU能进行int64位的数值计算吗？

先说结论，能。但比起64位的CPU，性能会慢一些。

如果说我用的是64位的CPU，那么我在计算两个int64的数值相加时，我就能将数据通过64位的总线，一次性存入到64位的寄存器，并在进行计算后返回到内存中。整个过程一步到位，一气呵成。

但如果我现在用的是32位的CPU，那就憋屈一点了，我虽然在代码里放了个int64的数值，但实际上CPU的寄存器根本放不下这么大的数据，因此最简单的方法是，将int64的数值，拆成前后两半，现在两个int64相加，就变成了4个int32的数值相加，并且后半部分加好了之后，拿到进位，才能去计算前面的部分，这里光是执行的指令数就比64位的CPU要多。所以理论上，会更慢些。

## 内存对齐字节对齐

简单来说，操作系统的cpu不是一个字节一个字节访问内存的，是按2,4,8这样的字长来访问的。

所以当处理器从存储器子系统读取数据至寄存器，或者，写寄存器数据到存储器，传送的数据长度通常是字长。

如32位系统访问粒度是4字节（bytes），64位系统的是8字节。

当被访问的数据长度为 `n` 字节且该数据地址为`n`字节对齐，那么操作系统就可以一次定位到数据，这样会更加高效。无需多次读取、处理对齐运算等额外操作。

-   内存对齐是为了cpu更高效访问内存中数据
-   struct的对齐是：如果类型 t 的对齐保证是 n，那么类型 t 的每个值的**地址**在运行时必须是 n 的倍数。

即 `uintptr(unsafe.Pointer(&x)) % unsafe.Alignof(x) == 0`

-   struct内字段如果填充过多，可以尝试重排，使字段排列更紧密，减少内存浪费
-   零大小字段要避免作为struct最后一个字段，会有内存浪费
-   32位系统上对64位字的原子访问要保证其是8bytes对齐的；当然如果不必要的话，还是用加锁（`mutex`）的方式更清晰简单


现代计算机中，内存空间按照**字节**划分，理论上可以从任何起始地址访问任意类型的变量。但实际中在访问特定类型变量时经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序一个接一个地存放，这就是对齐。
  
对齐跟数据在内存中的位置有关。为了使得CPU能快速对变量进行访问，变量存的起始地址必须具备某些特性，即“对齐”，比如4字节的int型,其起始地址应该位于4字节的边界上,即起始地址能够被4整除

### 为什么要字节对齐

某些平台对特定类型的数据只能从特定地址开始存取，而不允许其在内存中任意存放。例如，Motorola 68000 处理器不允许16位的字存放在奇地址，否则会触发异常，因此在这种架构下编程必须保证字节对齐。

==根本原因在于CPU访问数据的效率问题==

以32位机为例，它每次取32个位，也就是4个字节。以int型数据为例，如果它在内存中存放的位置按4字节对齐，也就是说1个int的数据全部落在计算机一次取数的区间内，那么只需要取一次就可以了。如果不对齐，很不巧，这个int数据刚好跨越了取数的边界，这样就需要取两次才能把这个int的数据全部取到。

节约空间：合理对齐，则节约空间；否则浪费空间。

## 字节序 

（大端存储，小端存储）

字节序，即字节的排列顺序。在计算机领域中，计算机内存中的字（word）由多个 字节（bytes）组成，这些字节的排列顺序叫做字节序。

在几乎所有的机器上，多字节对象都被存储在地址连续的内存中。假设一个整型变量`i = 0x1234567`占4个字节，恰好内存中空出来四个字节可以存放这个整型变量，内存中空出字节的地址是`0x100, 0x101, 0x102, 0x103`。**基于这个假设**介绍大端序和小端序

**大端序（Big Endian）：** 高位字节在低地址，低位字节在高地址。
**小端序（Little Endian）：** 低位字节在低地址，高位字节在高地址。

**why**？

计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。
但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。