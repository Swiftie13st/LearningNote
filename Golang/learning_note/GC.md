# GC

[5、Golang三色标记混合写屏障GC模式全分析 (yuque.com)](https://www.yuque.com/aceld/golang/zhzanb)

垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的内存对象，让出存储器资源。GC过程中无需程序员手动执行。GC机制在现代很多编程语言都支持，GC能力的性能与优劣也是不同语言之间对比度指标之一。

Golang在GC的演进过程中也经历了很多次变革，Go V1.3之前的标记-清除(mark and sweep)算法，Go V1.3之前的标记-清扫(mark and sweep)的缺点

-   Go V1.5的三色并发标记法
-   Go V1.5的三色标记为什么需要STW
-   Go V1.5的三色标记为什么需要屏障机制(“强-弱” 三色不变式、插入屏障、删除屏障 )
-   Go V1.8混合写屏障机制
-   Go V1.8混合写屏障机制的全场景分析

## Go V1.3之前的标记-清除(mark and sweep)算法

-   标记(Mark phase)
-   清除(Sweep phase)

### 步骤

**第一步**，暂停程序业务逻辑（STW）, 分类出可达和不可达的对象，然后做上标记。

![image-202303281611143](attachments/image-202303281611143.png)

**第二步**, 开始标记，程序找出它所有可达的对象，并做上标记。如下图所示：

![image-202303281612437](attachments/image-202303281612437.png)

**第三步**,  标记完了之后，然后开始清除未标记的对象. 结果如下。

![image-202303281612025](attachments/image-202303281612025.png)

操作非常简单，但是有一点需要额外注意：mark and sweep算法在执行的时候，需要程序暂停！即 `STW(stop the world)`，STW的过程中，CPU不执行用户代码，全部用于垃圾回收，这个过程的影响很大，所以STW也是一些回收机制最大的难题和希望优化的点。所以在执行第三步的这段时间，程序会暂定停止任何工作，卡在那等待回收执行完毕。

**第四步**, 停止暂停，让程序继续跑。然后循环重复这个过程，直到process程序生命周期结束。

### 缺点

标记清除算法明了，过程鲜明干脆，但是也有非常严重的问题。

-   STW，stop the world；让程序暂停，程序出现卡顿 **(重要问题)**；
-   标记需要扫描整个heap；
-   清除数据会产生heap碎片。

Go V1.3版本之前就是以上来实施的,  在执行GC的基本流程就是首先启动STW暂停，然后执行标记，再执行数据回收，最后停止STW，如图所示。

![image-202303281613681](attachments/image-202303281613681.png)


从上图来看，全部的GC时间都是包裹在STW范围之内的，这样貌似程序暂停的时间过长，影响程序的运行性能。所以Go V1.3 做了简单的优化,将STW的步骤提前, 减少STW暂停的时间范围.如下所示

![image-202303281614295](attachments/image-202303281614295.png)

上图主要是将STW的步骤提前了一步，因为在Sweep清除的时候，可以不需要STW停止，因为这些对象已经是不可达对象了，不会出现回收写冲突等问题。

但是无论怎么优化，Go V1.3都面临这个一个重要问题，就是**mark-and-sweep 算法会暂停整个程序** 。

Go是如何面对并这个问题的呢？接下来G V1.5版本 就用**三色并发标记法**来优化这个问题.

## Go V1.5的三色并发标记法

Golang中的垃圾回收主要应用三色标记法，GC过程和其他用户goroutine可并发运行，但需要一定时间的**STW(stop the world)**，所谓**三色标记法**实际上就是通过三个阶段的标记来确定清楚的对象都有哪些？我们来看一下具体的过程。

### 步骤

**第一步** , 每次新创建的对象，默认的颜色都是标记为“白色”，如图所示。


![image-1651035738281-051f7a89-e07f-418c-ad0e-7cb94ef1a3b8](attachments/image-1651035738281-051f7a89-e07f-418c-ad0e-7cb94ef1a3b8.png)

上图所示，我们的程序可抵达的内存对象关系如左图所示，右边的标记表，是用来记录目前每个对象的标记颜色分类。这里面需要注意的是，所谓“程序”，则是一些对象的根节点集合。所以我们如果将“程序”展开，会得到类似如下的表现形式，如图所示。

![image-1651035821416-b0ad644e-ef8e-440a-bbf4-b9e24a7e0257](attachments/image-1651035821416-b0ad644e-ef8e-440a-bbf4-b9e24a7e0257.jpeg)

**第二步**, 每次GC回收开始, 会从根节点开始遍历所有对象，把遍历到的对象从白色集合放入“灰色”集合如图所示。

![image-1651035842467-7341846f-6dee-4f8b-ad37-dc9723aa6407](attachments/image-1651035842467-7341846f-6dee-4f8b-ad37-dc9723aa6407.jpeg)  
这里 要注意的是，本次遍历是一次遍历，非递归形式，是从程序抽次可抵达的对象遍历一层，如上图所示，当前可抵达的对象是对象1和对象4，那么自然本轮遍历结束，对象1和对象4就会被标记为灰色，灰色标记表就会多出这两个对象。

**第三步**, 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合，如图所示。

![image-1651035859950-96053775-24f7-4bdc-a1fb-295747055b3e](attachments/image-1651035859950-96053775-24f7-4bdc-a1fb-295747055b3e.jpeg)  
这一次遍历是只扫描灰色对象，将灰色对象的第一层遍历可抵达的对象由白色变为灰色，如：对象2、对象7. 而之前的灰色对象1和对象4则会被标记为黑色，同时由灰色标记表移动到黑色标记表中。

**第四步**, 重复**第三步**, 直到灰色中无任何对象，如图所示。 

![image-1651035907012-927d6cbc-686b-4f81-a1de-097ac7598a8e](attachments/image-1651035907012-927d6cbc-686b-4f81-a1de-097ac7598a8e.jpeg)  
![image-1651035916208-9c293dc0-8988-4180-a9b7-412e2599af0e](attachments/image-1651035916208-9c293dc0-8988-4180-a9b7-412e2599af0e.jpeg)

当我们全部的可达对象都遍历完后，灰色标记表将不再存在灰色对象，目前全部内存的数据只有两种颜色，黑色和白色。那么黑色对象就是我们程序逻辑可达（需要的）对象，这些数据是目前支撑程序正常业务运行的，是合法的有用数据，不可删除，白色的对象是全部不可达对象，目前程序逻辑并不依赖他们，那么白色对象就是内存中目前的垃圾数据，需要被清除。

**第五步**: 回收所有的白色标记表的对象. 也就是回收垃圾，如图所示。  
  
以上我们将全部的白色对象进行删除回收，![image-1651035960263-e50436a6-4a3c-48f9-82cb-bb5729d71116](attachments/image-1651035960263-e50436a6-4a3c-48f9-82cb-bb5729d71116.jpeg)剩下的就是全部依赖的黑色对象。

以上便是`三色并发标记法`，不难看出，我们上面已经清楚的体现`三色`的特性。但是这里面可能会有很多并发流程均会被扫描，执行并发流程的内存可能相互依赖，为了在GC过程中保证数据的安全，我们在开始三色标记之前就会加上STW，在扫描确定黑白对象之后再放开STW。但是很明显这样的GC扫描的性能实在是太低了。

那么Go是如何解决标记-清除(mark and sweep)算法中的卡顿(stw，stop the world)问题的呢？

## 没有STW的三色标记法

先抛砖引玉，我们加入如果没有STW，那么也就不会再存在性能上的问题，那么接下来我们假设如果三色标记法不加入STW会发生什么事情？  
我们还是基于上述的三色并发标记法来说, 他是一定要依赖STW的. 因为如果不暂停程序, 程序的逻辑改变对象引用关系, 这种动作如果在标记阶段做了修改，会影响标记结果的正确性，我们来看看一个场景，如果三色标记法, 标记过程不使用STW将会发生什么事情?

我们把初始状态设置为已经经历了第一轮扫描，目前黑色的有对象1和对象4， 灰色的有对象2和对象7，其他的为白色对象，且对象2是通过指针p指向对象3的，如图所示。

![image-1651035994109-83972e84-be65-4950-b9bf-a48b676856a5](attachments/image-1651035994109-83972e84-be65-4950-b9bf-a48b676856a5.jpeg)

  

现在如何三色标记过程不启动STW，那么在GC扫描过程中，任意的对象均可能发生读写操作，如图所示，在还没有扫描到对象2的时候，已经标记为黑色的对象4，此时创建指针q，并且指向白色的对象3。

![image-1651036029588-29e317e6-8f92-41ca-a28e-65153913d227](attachments/image-1651036029588-29e317e6-8f92-41ca-a28e-65153913d227.jpeg)

与此同时灰色的对象2将指针p移除，那么白色的对象3实则就是被挂在了已经扫描完成的黑色的对象4下，如图所示。

  
![image-1651036292354-f70d8185-66a2-4478-9036-b4de940285c5](attachments/image-1651036292354-f70d8185-66a2-4478-9036-b4de940285c5.jpeg)  
然后我们正常指向三色标记的算法逻辑，将所有灰色的对象标记为黑色，那么对象2和对象7就被标记成了黑色，如图所示。  
![image-1651036347628-d63c17c4-7cee-4149-8ce9-13cc11bbd343](attachments/image-1651036347628-d63c17c4-7cee-4149-8ce9-13cc11bbd343.jpeg)

  
那么就执行了三色标记的最后一步，将所有白色对象当做垃圾进行回收，如图所示。  
![image-1651036362636-5a98e196-e1cd-49fc-9542-1cb0772a41c4](attachments/image-1651036362636-5a98e196-e1cd-49fc-9542-1cb0772a41c4.jpeg)  
但是最后我们才发现，本来是对象4合法引用的对象3，却被GC给“误杀”回收掉了。

可以看出，有两种情况，在三色标记法中，是不希望被发生的。

-   条件1: 一个白色对象被黑色对象引用**(白色被挂在黑色下)**
-   条件2: 灰色对象与它之间的可达关系的白色对象遭到破坏**(灰色同时丢了该白色)**  
    如果当以上两个条件同时满足时，就会出现对象丢失现象!

并且，如图所示的场景中，如果示例中的白色对象3还有很多下游对象的话, 也会一并都清理掉。

为了防止这种现象的发生，最简单的方式就是STW，直接禁止掉其他用户程序对对象引用关系的干扰，但是**STW的过程有明显的资源浪费，对所有的用户程序都有很大影响**。那么是否可以在保证对象不丢失的情况下合理的尽可能的提高GC效率，减少STW时间呢？答案是可以的，我们只要使用一种机制，尝试去破坏上面的两个必要条件就可以了。

## 屏障机制

我们让GC回收器，满足下面两种情况之一时，即可保对象不丢失。  这两种方式就是“强三色不变式”和“弱三色不变式”。

### 强三色不变式

**不存在黑色对象引用到白色对象的指针。**
强三色不变色实际上是强制性的不允许黑色对象引用白色对象，这样就不会出现有白色对象被误删的情况。

![image-1651036383192-cb6b9fe9-4946-47da-bb9a-643f0c38a654](attachments/image-1651036383192-cb6b9fe9-4946-47da-bb9a-643f0c38a654.jpeg)

### 弱三色不变式

**所有被黑色对象引用的白色对象都处于灰色保护状态。**

![image-1651036404003-e0ea569e-7a8a-4d9f-a08f-4bb9ed5c64ed](attachments/image-1651036404003-e0ea569e-7a8a-4d9f-a08f-4bb9ed5c64ed.jpeg)

  
弱三色不变式强调，黑色对象可以引用白色对象，但是这个白色对象必须存在其他灰色对象对它的引用，或者可达它的链路上游存在灰色对象。 这样实则是黑色对象引用白色对象，白色对象处于一个危险被删除的状态，但是上游灰色对象的引用，可以保护该白色对象，使其安全。

为了遵循上述的两个方式，GC算法演进到两种屏障方式，他们“插入屏障”, “删除屏障”。

### 插入屏障

`具体操作`: 在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)

`满足`: **强三色不变式**. (不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色)

伪码如下:
```go
添加下游对象(当前下游对象slot, 新下游对象ptr) {   
  //1
  标记灰色(新下游对象ptr)   
  
  //2
  当前下游对象slot = 新下游对象ptr  				  
}
```

场景：
```go
A.添加下游对象(nil, B)   //A 之前没有下游， 新添加一个下游对象B， B被标记为灰色
A.添加下游对象(C, B)     //A 将下游对象C 更换为B，  B被标记为灰色
```


这段伪码逻辑就是写屏障,. 我们知道,黑色对象的内存槽有两种位置, `栈`和`堆`. 栈空间的特点是容量小,但是要求相应速度快,因为函数调用弹出频繁使用, 所以“插入屏障”机制,在**栈空间的对象操作中不使用**. 而仅仅使用在堆空间对象的操作中.


接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。


![image-1651036442131-91f36e55-5c94-4931-a140-58ff5627c681](attachments/image-1651036442131-91f36e55-5c94-4931-a140-58ff5627c681.jpeg)

---

![image-1651036449149-2fb53d7c-d351-4305-84a8-7a1b51806ce4](attachments/image-1651036449149-2fb53d7c-d351-4305-84a8-7a1b51806ce4.jpeg)

---

![image-1651036456806-6b1aeb27-831d-43d9-a79e-4dad49fea07d](attachments/image-1651036456806-6b1aeb27-831d-43d9-a79e-4dad49fea07d.jpeg)

---

![image-1651036465710-e260440e-b53d-4f76-a826-842e28666efe](attachments/image-1651036465710-e260440e-b53d-4f76-a826-842e28666efe.jpeg)

---

![image-1651036474130-755abe1f-d070-47e6-93cf-7aa129489206](attachments/image-1651036474130-755abe1f-d070-47e6-93cf-7aa129489206.jpeg)

---

![image-1651036481384-c4e44929-09e4-4a05-81bb-b5e9ed195982](attachments/image-1651036481384-c4e44929-09e4-4a05-81bb-b5e9ed195982.jpeg)

  

但是如果栈不添加,当全部三色标记扫描之后,栈上有可能依然存在白色对象被引用的情况(如上图的对象9).  所以要对栈重新进行三色标记扫描, 但这次为了对象不丢失, 要对本次标记扫描启动STW暂停. 直到栈空间的三色标记结束.

---

![image-1651036522462-5e0c1ea9-e136-45c8-9648-bf691b270431](attachments/image-1651036522462-5e0c1ea9-e136-45c8-9648-bf691b270431.jpeg)

---

![image-1651036531031-d37d4239-9b13-4d0e-a9cc-d7bc230d56a8](attachments/image-1651036531031-d37d4239-9b13-4d0e-a9cc-d7bc230d56a8.jpeg)

---

![image-1651036538543-d84895c0-451d-4c49-9c67-f77dcf5a3ae9](attachments/image-1651036538543-d84895c0-451d-4c49-9c67-f77dcf5a3ae9.jpeg)

---

最后将栈和堆空间 扫描剩余的全部 白色节点清除.  这次STW大约的时间在10~100ms间.

  

![image-1651036559017-4564c417-9059-415c-aa81-d9504ac4e00b](attachments/image-1651036559017-4564c417-9059-415c-aa81-d9504ac4e00b.jpeg)

---


### 删除屏障

`具体操作`: 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。

`满足`: **弱三色不变式**. (保护灰色对象到白色对象的路径不会断)

伪代码：

```go
添加下游对象(当前下游对象slot， 新下游对象ptr) {
  //1
  if (当前下游对象slot是灰色 || 当前下游对象slot是白色) {
  		标记灰色(当前下游对象slot)     //slot为被删除对象， 标记为灰色
  }
  
  //2
  当前下游对象slot = 新下游对象ptr
}
```

场景：

```go
A.添加下游对象(B, nil)   //A对象，删除B对象的引用。  B被A删除，被标记为灰(如果B之前为白)
A.添加下游对象(B, C)		 //A对象，更换下游B变成C。   B被A删除，被标记为灰(如果B之前为白)
```

接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。

![image-1651036621717-80ea507c-99a9-4e61-9bde-b4cd33f478f4](attachments/image-1651036621717-80ea507c-99a9-4e61-9bde-b4cd33f478f4.jpeg)

  

![image-1651036629775-bc69d08e-c270-46ad-b82b-5ad0d0bdcb64](attachments/image-1651036629775-bc69d08e-c270-46ad-b82b-5ad0d0bdcb64.jpeg)

  

![image-1651036637089-52a0fc99-7805-40d0-aee7-4124017e90c8](attachments/image-1651036637089-52a0fc99-7805-40d0-aee7-4124017e90c8.jpeg)

  

![image-1651036644794-05a69ec6-70c9-44c7-9493-44028ba4df7f](attachments/image-1651036644794-05a69ec6-70c9-44c7-9493-44028ba4df7f.jpeg)

  

![image-1651036653171-57e34942-2091-4d76-83f3-0b084ebd577d](attachments/image-1651036653171-57e34942-2091-4d76-83f3-0b084ebd577d.jpeg)

  

![image-1651036660503-4f49f494-8ede-45dd-8a4c-bfa5499b307a](attachments/image-1651036660503-4f49f494-8ede-45dd-8a4c-bfa5499b307a.jpeg)

  

  

![image-1651036668136-8592bd0f-2210-48d9-b43d-7c4a2e16a287](attachments/image-1651036668136-8592bd0f-2210-48d9-b43d-7c4a2e16a287.jpeg)

这种方式的回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。

## Go V1.8的混合写屏障(hybrid write barrier)机制

插入写屏障和删除写屏障的短板：

-   插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活；
-   删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。

Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了STW的时间。结合了两者的优点。

### 混合写屏障规则

`具体操作`:

1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，
2、GC期间，任何在栈上创建的新对象，均为黑色。
3、被删除的对象标记为灰色。
4、被添加的对象标记为灰色。

`满足`: 变形的**弱三色不变式**.

伪代码：
```go
添加下游对象(当前下游对象slot, 新下游对象ptr) {
  	//1 
		标记灰色(当前下游对象slot)    //只要当前下游对象被移走，就标记灰色
  	
  	//2 
  	标记灰色(新下游对象ptr)
  		
  	//3
  	当前下游对象slot = 新下游对象ptr
}
```

>这里我们注意， 屏障技术是不在栈上应用的，因为要保证栈的运行效率。

### 混合写屏障的具体场景分析

接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。

注意混合写屏障是Gc的一种屏障机制，所以只是当程序执行GC的时候，才会触发这种机制。

##### GC开始：扫描栈区，将可达对象全部标记为黑
![image-1651036708530-f7c50de5-6a63-45dc-baef-f53b1b42eb62](attachments/image-1651036708530-f7c50de5-6a63-45dc-baef-f53b1b42eb62.jpeg)![image-1651036716310-65729a9c-d8df-40ce-9c2b-d35228278791](attachments/image-1651036716310-65729a9c-d8df-40ce-9c2b-d35228278791.jpeg)  

---

##### 场景一： 对象被一个堆对象删除引用，成为栈对象的下游

  

伪代码
```go
//前提：堆对象4->对象7 = 对象7；  //对象7 被 对象4引用
栈对象1->对象7 = 堆对象7；  //将堆对象7 挂在 栈对象1 下游
堆对象4->对象7 = null；    //对象4 删除引用 对象7
```

![image-1651036737874-a2f71441-c4f9-4f74-8c8a-c5a53bd35d4c](attachments/image-1651036737874-a2f71441-c4f9-4f74-8c8a-c5a53bd35d4c.jpeg)

  

![image-1651036745104-24b7bf17-27b9-4531-97b7-48c5b7e64fac](attachments/image-1651036745104-24b7bf17-27b9-4531-97b7-48c5b7e64fac.jpeg)

  

##### 场景二： 对象被一个栈对象删除引用，成为另一个栈对象的下游

  

伪代码
```go
new 栈对象9；
对象8->对象3 = 对象3；      //将栈对象3 挂在 栈对象9 下游
对象2->对象3 = null；      //对象2 删除引用 对象3
```

![image-1651036778055-bda31c21-45dc-4602-9241-11a33b6393a6](attachments/image-1651036778055-bda31c21-45dc-4602-9241-11a33b6393a6.jpeg)

  

![image-1651036785024-0edb665e-7b4b-46e3-b8cf-1d4ff02e73cd](attachments/image-1651036785024-0edb665e-7b4b-46e3-b8cf-1d4ff02e73cd.jpeg)

  

![image-1651036791814-78eed337-a9ac-42d9-bcd8-99a21c01111c](attachments/image-1651036791814-78eed337-a9ac-42d9-bcd8-99a21c01111c.jpeg)

  

##### 场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游

  

伪代码
```go
堆对象10->对象7 = 堆对象7；       //将堆对象7 挂在 堆对象10 下游
堆对象4->对象7 = null；         //对象4 删除引用 对象7
```

![image-1651036826144-893174fb-0111-4838-9f7d-38fe2f89648a](attachments/image-1651036826144-893174fb-0111-4838-9f7d-38fe2f89648a.jpeg)

  

![image-1651036833484-a18064d9-1329-42d7-8687-8a029542e85e](attachments/image-1651036833484-a18064d9-1329-42d7-8687-8a029542e85e.jpeg)

  

![image-1651036840569-f50df9db-5219-48fe-83ff-c3545ed4dec4](attachments/image-1651036840569-f50df9db-5219-48fe-83ff-c3545ed4dec4.jpeg)

  

##### 场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游

  

伪代码
```go
堆对象10->对象7 = 堆对象7；       //将堆对象7 挂在 堆对象10 下游
堆对象4->对象7 = null；         //对象4 删除引用 对象7
```

![image-1651036859560-21a75ea4-ee66-46ae-81bc-ce4e697c3814](attachments/image-1651036859560-21a75ea4-ee66-46ae-81bc-ce4e697c3814.jpeg)

![image-1651036864959-929ec428-e8d8-48a9-aaeb-e2589723ec62](attachments/image-1651036864959-929ec428-e8d8-48a9-aaeb-e2589723ec62.jpeg)

![image-1651036876957-976a0ac6-6c82-4eca-88f3-10180782281c](attachments/image-1651036876957-976a0ac6-6c82-4eca-88f3-10180782281c.jpeg)


Golang中的混合写屏障满足`弱三色不变式`，结合了删除写屏障和插入写屏障的优点，只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行re-scan操作了，减少了STW的时间。


## 总结
  
GoV1.3- 普通标记清除法，整体过程需要启动STW，效率极低。

GoV1.5- 三色标记法， 堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通

GoV1.8-三色标记法，混合写屏障机制， 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高。