# 面试 mysql调优

## 索引，B+树

### 为什么要控制各个字段大小？控制单行数据大小

表设计，严格控制字段的大小，B+树的高出扇性

假设主键是bigint（自增，或者snowflake生成），占8个字节
- 假设id为1，存储为80000001(256)，id为3，存储为80000003(256)

存储器每页16KB
16KB / (8B + 6B) = 1170.29，以1100计算
第一层，指向1100二层节点
第二层，指向1100^2 三层节点，10\^6，1百万
第三层：假设一行数据占16KB，则存储1百万数据（16KB/16KB \* 1百万）；假设一行数据占1KB，则存储一千六百万数据（16KB/1KB\ * 1百万）；
因此需要**严格控制存储字段大小**

每次加载16KB内存页，**二分查找索引**，Olog(N)，再找下一层，共三次I/O索引

### MySQL底层数据结构为什么采用B+树？为什么不用B树，二叉树，哈希表？

**B树**非叶子节点和叶子节点都会存储数据和索引，这样导致一页中存储的键值减少，指针跟着减少，要保存大量数据只能增加树的高度，导致性能降低。假设参数规格不变，存储一半数据，一半索引，第三层550 + 550 ^ 2 + 550 ^2 * 16= 480万，大概是B+树的1/4；
**二叉树**存储相同的节点树的深度更高，则**需要更多的I/O读取次数**

**哈希表**，在没有冲突的情况下，时间复杂度为O(1)，桶位转换为链表/红黑树，时间复杂度为O(logN)，比B+树快，但：

1. **不支持模糊匹配%**，无法使用LIKE"%"，由于哈希计算没有局部特性，例如hash(皮卡丘)跟hash(皮卡)没有关系
2. **不支持范围匹配**， **不支持排序**，没有顺序性，例如查询1~100，采用B+树查到1，再后遍历，直到大于100则结束，而且数据一般在连续内存页中
3. **哈希冲突**问题
4. 不支持联合索引（最左匹配原则）

### 最左前缀原则

[面试中常被提到的最左前缀匹配原则 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/142852474)
为什么可以模糊查询？
在mysql建立联合索引时会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配，

顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。

最左前缀匹配原则，非常重要的原则，建立一个索引，对于索引中的字段，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，==a,b,d的顺序可以任意调整==。
=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式

### 索引分类

**聚簇索引**，每张表==只有一个==聚簇索引B+树，以primary key构建，非叶子节点存储主键（主键类型大小，bigint为8字节）和下级索引（6个字节），叶子节点存储整行数据
**辅助索引**，也是B+树，每张表可以有多个辅助索引，非叶子节点存储主键和索引，叶子节点存储主键和索引辅助属性（存储主键，用于回表查询）
**联合索引**，不包括primary key的联合索引为辅助索引，索引顺序按属性的离散性降序排列（show index，cardinality（kind/sum）趋近于1）

**覆盖索引**，==不是索引，是一种效果==，索引下推。覆盖索引是select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖。**避免回表的产生从而减少IO**，提升性能

### 如何定义索引？

需要看字段内容的随机性，**随机度越高作为索引的效率越高**。
看离散度可以用show index，如果cardinality（随更新表实时变化）越接近1（离散度越高）越适合做索引，同时要结合实际开发的业务需求。

### 索引失效

- like未使用最左前缀，where A  like "%China"，即以==%开头会索引失效==
- or会使索引失效，当==or两端其中一个条件没有使用索引==。如果查询字段相同，也可以使用索引。例如  where A = a1 or A = a2（生效），where A=a or B = b （失效）
- 联合查询为使用最左前缀，例如联合索引（A，B），例如：where A = a and B = b 会使用索引，where B = b 不会使用索引。即==当创建联合索引中where没有从联合索引的首个索引开始时==索引失效
- +-\*/运算，当==索引字段被运算时==索引失效
- 在索引列上的操作，or、!= （<>）,not in，is not 等，即==取非结果集==
- is null、is not null；==索引本身不对null值的数据做处理==。理论上不要让字段为null，处理方法：字段强制不为null、字段默认值
- 使用==内置函数==upper()等，以及例如：使用索引时，数字和string==类型不统一==，varchar = 12345没有加引号，内部实际使用了convert函数导致失效
- 版本：不同版本
	```sql
	SELECT * FROM tb WHERE a > 3; // a 辅助索引
	```
	MySQL<5.6：走全表扫描，不使用索引
	 **离散读**：a > 3, 4 5 6 7 8 随机查 5 7 4 8 3, 5 * 3 次io
	MySQL>=5.6 ：走索引
- 搜索一个索引而在另一个索引上做 order by， where A = a order by B，只会使用A上的索引，因为查询只使用一个索引。

